= Building Apps around the Event Mesh
:sectnums:
:sectlinks:
:doctype: book

= Architecture 

The architecture of an event mesh-enabled system is a paradigm shift from 
traditional transactional designs to an eventual consistency model. This design
aligns better with real-world processes, where different parts of a system may
operate asynchronously yet collaboratively. In this section, we explore the
technologies, flow, and structure that make the event mesh architecture
resilient, scalable, and developer-friendly.

The solution employs _Command Query Responsibility Segregation (CQRS)_ to
separate commands and queries. Commands are modeled as asynchronous events and
handled by the event mesh. Queries are synchronous operations safe to retry.

[#tech_stack]
== Technology Stack

Here's the list of technologies used in this solution and its examples:

* Red Hat supported products
** https://www.redhat.com/en/technologies/cloud-computing/openshift[Red Hat OpenShift]
   &mdash; Orchestrate containerized applications. Based on https://kubernetes.io/[Kuberentes].
** https://www.redhat.com/en/technologies/cloud-computing/openshift/serverless[Red Hat OpenShift Serverless]
   &mdash; Provides the _Event Mesh_ and _Serverless_ capabilities. Based on https://knative.dev[Knative].
** https://swc.saas.ibm.com/en-us/redhat-marketplace/products/red-hat-amq[Red Hat AMQ Streams]
   &mdash; (Optional) Provides a persistence for _Event Mesh_, likely needed in production. Based on https://strimzi.io/[Strimzi].
* Other open source technologies:
** https://cloudevents.io/[CloudEvents] &mdash; Provides a standard for event metadata
** Rust and https://access.redhat.com/products/quarkus[Quarkus] &mdash; Implementation examples.
** https://opentelemetry.io/[OpenTelemetry] &mdash; (Optional) Facilitates tracing for observability.

[#in_depth]
== An in-depth look at the solution's architecture

////
Technical description including all or some of the following: architecture ired diagrams. In-depth details of the decisions made and solutions used. Description of each service and what it is used for. Description of any integration.
////

=== Problem Analysis

Traditional transactional systems enforce strict consistency, which slows 
applications and distorts business logic. In our example, Cabs app, must
account for a real-life events like exiting a cab, even if dependent systems
(e.g. invoicing) experience downtime. Throwing errors, while keeps the
consistency in already stored data, loses the new data from real life events.
This leads to a bad impression by the end-users, and distorts the actual
business process.

=== Solution Breakdown

Split services into independently operating microservices with distinct responsibilities.

Utilize CQRS to separate commands (asynchronous state changes) from queries (synchronous, retry-safe reads).

=== Event Mesh Flow

Events like CompleteTransit are published as CloudEvents to a Knative broker.

Triggers route events dynamically to the appropriate microservices.

Services process events, update state, and emit new events for downstream consumers.

=== Using images 

image::red_hat_open-hybrid-cloud.png[width=30%]

{empty}

=== Embedding HTML

++++
  <br>
  <h3> Embed HTML by surrounding it with with four +s before and after. </h3>
  <span>View the ascii doc to learn more</span>
  <br> 
++++


=== Different decorators

[TIP]
====
This is a Tip
====

[NOTE]
====
This is a NOTE
====

[WARNING]
====
This is a WARNING
====

[IMPORTANT]
====
This is IMPORTANT
====


=== Creating  tables
 
[cols="1a,1a,1a"]
|===
| *Column A*  | Column *A* | _Column C_
|
* Lorem Ipsum
* Lorem Ipsum

|
* Lorem Ipsum
* Lorem Ipsum

|
* Lorem Ipsum
* Lorem Ipsum
|===



=== Content that can be copied

Click below to copy the content
[.console-input]
[source,shell script]
----
oc version #openshift cli client
oc login --token=<token> --server=<server>
----


[#more_tech]
== About the Technology Stack

If you want to include more details about the tech stack you used, this is the place.