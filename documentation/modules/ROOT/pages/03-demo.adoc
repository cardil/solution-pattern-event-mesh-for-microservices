= Building Apps around the Event Mesh
:sectnums:
:sectlinks:
:doctype: book

= See the Solution in Action

== Demonstration

Let's take a look at the following example.
We'll be looking at a Cabs ride-sharing application, that mimics real-world solutions of similar kind.
The application is written in a popular Java framework.

=== Initial application

[IMPORTANT]
====
The following example should be considered as suboptimal, most likely a counterexample!
====

Here's a method from the Cabs application that handles the completion of a ride.

[source,java]
----
@Transactional // <1>
public void completeTransit(Long driverId, UUID requestUUID, Address destinationAddress) {
    destinationAddress = addressRepository.save(destinationAddress); // <2>
    TransitDetailsDTO transitDetails = transitDetailsFacade.find(requestUUID);
    if (!driverService.exists(driverId)) {
        throw new IllegalArgumentException("Driver does not exist, id = " + driverId);
    }
    Address from = addressRepository.getByHash(transitDetails.from.getHash());
    Address to = addressRepository.getByHash(destinationAddress.getHash());
    Money finalPrice = completeTransitService.completeTransit(
      driverId, requestUUID, from, to); // <2>
    Money driverFee = driverFeeService.calculateDriverFee(
      finalPrice, driverId);
    driverService.markNotOccupied(driverId); // <2>
    transitDetailsFacade.transitCompleted(requestUUID,
      Instant.now(clock), finalPrice, driverFee); // <2>
    awardsService.registerMiles(transitDetails.client.getId(),
      transitDetails.transitId); // <2>
    invoiceGenerator.generate(finalPrice.toInt(),
      transitDetails.client.getName() + " " +
      transitDetails.client.getLastName()); // <2>
    eventsPublisher.publish(new TransitCompleted(
      transitDetails.client.getId(), transitDetails.transitId,
      transitDetails.from.getHash(), destinationAddress.getHash(),
      transitDetails.started, Instant.now(clock), Instant.now(clock))
    ); // <2>
}
----

[CAUTION]
====
There are issues with the above method.

<1> It uses the `+@Transational+` annotation, and modify number of unrelated data stores.
// This means that when one of those operations fails, the whole processing will be rolled back.
// In effect, the end-user will receive a nasty error message.

<2> It merges different, business domains.
// This makes it hard to understand and maintain.
// It isn't required to all of those operations complete at the same time.
====

Similar methods are, unfortunately, quite common in business applications.
At first glance, many developers don't see any problems with similar code.
Let's break down the problems in detail.

==== Overuse of transactional processing

The transactional processing has been the cornerstone of many business applications.
However, in most cases, the transactional processing isn't the best fit for real-world processes.

In our example, when the ride finishes, that's a real-world situation.
However, the example uses the `+@Transational+` annotation, and operate on number of unrelated data.
This means that when one of those operations fails, the whole processing will be rolled back.
In effect, the end-user will receive a nasty error message.

[NOTE]
====
Outages from the dependant services must not invalidate the main intent.
In fact, all the operations in this example could happen independently, and at different, yet reasonable times.
====

==== Bundling of different logical domains

Our example is also very chatty, and hard to understand at first glance.
In fact, this is quite common in similar applications.
The code starts small, easy to understand.
When new features are added, it keeps growing as developers cramp new instructions into methods like `+completeTransit+`.

Of course, the developers could re-architect the code, to extract instructions to a separate blocks, but that is just a half-measure.
Still, the application will do all the operations, starting from `+completeTransit+` method in the same time, and withing the same _"script"_.

=== Refactoring

In this section, we'll refactor the Cabs application.
The refactoring will be limited to make the process easy to understand.

image::https://www.plantuml.com/plantuml/svg/VP1DJiCm58JtFiMZ-rmWYwgqeHkeX2WNUBK7Ok4ubdyYzVQuZKbe5TZ5olTcFiqcHFOnTKOyn1OTIC8d0xPLdwBH5iBb_rfgnpRIwWMVBC_qwDoAED3ul4MUBKSzW9u6vES1eRsYMzz_mT-YZS-W3tJeLUwyOdlW23zeYJkK8vyuZ52p5O9bRk687uTYLgrB4zNqcav6XvPsR6GocTsZQ8d2L1aV3slQzVP3-uuKpCNgB1JkEwQpzI_FcjxoL5XgcUvdMioVL4soi-iuIOQcE5N259RYPgKYMNJ-3lfdkMPRqp7s7lJkjQFBvWihR61Lwimt[width=100%]

////
Online editor:
https://www.plantuml.com/plantuml/uml/VP1DJiCm58JtFiMZ-rmWYwgqeHkeX2WNUBK7Ok4ubdyYzVQuZKbe5TZ5olTcFiqcHFOnTKOyn1OTIC8d0xPLdwBH5iBb_rfgnpRIwWMVBC_qwDoAED3ul4MUBKSzW9u6vES1eRsYMzz_mT-YZS-W3tJeLUwyOdlW23zeYJkK8vyuZ52p5O9bRk687uTYLgrB4zNqcav6XvPsR6GocTsZQ8d2L1aV3slQzVP3-uuKpCNgB1JkEwQpzI_FcjxoL5XgcUvdMioVL4soi-iuIOQcE5N259RYPgKYMNJ-3lfdkMPRqp7s7lJkjQFBvWihR61Lwimt

@startuml
!theme materia-outline
participant "Legacy App" as Legacy
participant "Knative _Event Mesh_" as Broker
participant "Drivers Module" as FeeService
participant "Database" as DB

activate Legacy
Legacy -> Broker : Publish CalculateFee Event
Broker --> Legacy: Confirm delivery
deactivate Legacy

Broker -> FeeService: Route CalculateFee Event
activate FeeService
FeeService --> Broker: Publish DriverFeeCalculated Event
deactivate FeeService

Broker -> Legacy: Route DriverFeeCalculated Event
activate Legacy
Legacy -> DB: Store Trip Data
deactivate Legacy
@enduml
////

The diagram illustrates the flow of events between the legacy application, the Knative _Event Mesh_, the fee calculator service, and the datastore.

In this video you can see xpto:

video::Rc5IO6S6ZOk[youtube,width=800,height=480]

Next, you can learn how to walkthrough this demo.

== Run the demonstration

=== Before getting started

To run this demo, you will need xpto.
Adding to that, make sure to have:

* ABC
* XYZ
* XPTO

=== Installing the demo

Installation guide and basic test of the demo installation if needed

=== Walkthrough guide

How to run through the demo
