<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Building Apps around the Event Mesh :: Solution Patterns for Cloud Native Architectures</title>
    <link rel="canonical" href="https://redhat-solution-patterns.github.io/solution-patterns/solution-pattern-event-mesh-for-microservices/03-demo.html">
    <link rel="prev" href="02-architecture.html">
    <link rel="next" href="developer-resources.html">
    <meta name="generator" content="Antora 3.0.0">
    <link rel="stylesheet" href="../_/css/site.css">
<link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" style="font-size: 20px; color: white"
        href="https://redhat-solution-patterns.github.io/solution-patterns">
        <img src="../_/img/logo.png" height="35px" alt="Solution Patterns">&nbsp; Solution Patterns for Cloud Native Architectures</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Architectures &amp; Patterns</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://www.redhat.com/architect/portfolio/" target="_blank">Portfolio Architecture&nbsp; </a>
            <a class="navbar-item" href="https://redhat-solution-patterns.github.io/solution-patterns/patterns.html"  target="_blank">Solution Patterns </a>
            <a class="navbar-item" href="https://validatedpatterns.io/" target="_blank">Validated Patterns&nbsp;</a>
            <a class="navbar-item" href="https://catalog.redhat.com/solutions" target="_blank">Ecosystem Solutions&nbsp;</a>
          </div>
        </div>

        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" target="_blank" href="https://developers.redhat.com">Red Hat Developers</a>
            <a class="navbar-item" target="_blank" href="https://developers.redhat.com/app-dev-platform">App Dev Platform</a>
            <a class="navbar-item" target="_blank" href="https://www.redhat.com/en/products/application-foundations">Red Hat Application Services</a>
          </div>
        </div>

          <a class="navbar-item" target="_blank" href="https://github.com/redhat-solution-patterns/redhat-solution-patterns.github.io/issues">Feedback</a>
          <a class="navbar-item" target="_blank" href="https://redhat-solution-patterns.github.io/solution-patterns/contributors-guide.html">Contribute</a>

      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="solution-pattern-event-mesh-for-microservices" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html" class=" query-params-link">Event Mesh For Applications</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">1. Home page</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index.html#use-cases">1.1 Use cases</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index.html#_the_story">1.2 The story behind this solution pattern</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index.html#_the_solution">1.3 The solution</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="02-architecture.html">2. Architecture</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-architecture.html#tech_stack">2.1. Technology stack</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-architecture.html#in_depth">2.2. An in-depth look at the solution&#8217;s architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-architecture.html#more_tech">2.3. More about the technology stack</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03-demo.html">3. See the Solution in Action</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_initial_application">3.1. Initial application</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_refactoring_plan">3.2. Refactoring plan</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_run_this_demonstration">3.3. Run this demonstration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_in_depth_refactoring">3.4. In-depth look at the refactoring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_conclusion">3.5. Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="developer-resources.html">4. Developer Resources</a>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-text"><a href="https://redhat-solution-patterns.github.io/solution-patterns/patterns.html" target="_blank" rel="noopener">Explore Red Hat Solution Patterns</a></span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Event Mesh For Applications</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Event Mesh For Applications</span>
      <ul class="versions">
        <li class="version is-current">
          <a href="index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Event Mesh For Applications</a></li>
    <li><a href="03-demo.html">3. See the Solution in Action</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/cardil/solution-pattern-event-mesh-for-microservices/edit/HEAD/documentation/modules/ROOT/pages/03-demo.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Building Apps around the Event Mesh</h1>
<h1 id="_see_the_solution_in_action" class="sect0"><a class="anchor" href="#_see_the_solution_in_action"></a><a class="link" href="#_see_the_solution_in_action">See the Solution in Action</a></h1>
<div class="openblock partintro">
<div class="content">
Let&#8217;s take a look at the following example.
We&#8217;ll be looking at a Cabs ride-sharing application, that resembles real-world solutions of similar kind.
The application is written in a popular Java framework.
</div>
</div>
<div class="sect1">
<h2 id="_initial_application"><a class="anchor" href="#_initial_application"></a><a class="link" href="#_initial_application">1. Initial application</a></h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following example should be considered as suboptimal, most likely a counterexample!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s a method from the Cabs application that handles the completion of a ride.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Transactional <i class="conum" data-value="1"></i><b>(1)</b>
public void completeTransit(Long driverId, UUID requestUUID, Address destinationAddress) {
    destinationAddress = addressRepository.save(destinationAddress); <i class="conum" data-value="2"></i><b>(2)</b>
    TransitDetailsDTO transitDetails = transitDetailsFacade.find(requestUUID);
    if (!driverService.exists(driverId)) {
        throw new IllegalArgumentException("Driver does not exist, id = " + driverId);
    }
    Address from = addressRepository.getByHash(transitDetails.from.getHash());
    Address to = addressRepository.getByHash(destinationAddress.getHash());

    Money finalPrice = completeTransitService.completeTransit(
      driverId, requestUUID, from, to); <i class="conum" data-value="2"></i><b>(2)</b>
    Money driverFee = driverFeeService.calculateDriverFee(finalPrice, driverId);
    driverService.markNotOccupied(driverId); <i class="conum" data-value="2"></i><b>(2)</b>

    transitDetailsFacade.transitCompleted(requestUUID, Instant.now(clock),
      finalPrice, driverFee); <i class="conum" data-value="2"></i><b>(2)</b>
    awardsService.registerMiles(transitDetails.client.getId(), transitDetails.transitId); <i class="conum" data-value="2"></i><b>(2)</b>
    invoiceGenerator.generate(finalPrice.toInt(),
      transitDetails.client.getName() + " " +
      transitDetails.client.getLastName()); <i class="conum" data-value="2"></i><b>(2)</b>

    eventsEventSender.publish(new TransitCompleted(
      transitDetails.client.getId(), transitDetails.transitId,
      transitDetails.from.getHash(), destinationAddress.getHash(),
      transitDetails.started, Instant.now(clock), Instant.now(clock))
    ); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are issues with the above method.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>It uses the <code>@Transational</code> annotation, and modify number of unrelated data stores.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>It merges different, business domains.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similar methods are, unfortunately, quite common in business applications.
At first glance, many developers don&#8217;t see any problems with similar code.
Let&#8217;s break down the problems in detail.</p>
</div>
<div class="sect2">
<h3 id="_overuse_of_transactional_processing"><a class="anchor" href="#_overuse_of_transactional_processing"></a><a class="link" href="#_overuse_of_transactional_processing">1.1. Overuse of transactional processing</a></h3>
<div class="paragraph">
<p>The transactional processing has been the cornerstone of many business applications.
However, in most cases, the transactional processing isn&#8217;t the best fit for real-world processes.</p>
</div>
<div class="paragraph">
<p>In our example, when the ride finishes, that&#8217;s a real-world situation.
However, the example uses the <code>@Transational</code> annotation, and operate on number of unrelated data.
This means that when one of those operations fails, the whole processing will be rolled back.
In effect, the end-user will receive a nasty error message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Outages from the dependant services must not invalidate the main intent.
In fact, all the operations in this example could happen independently, and at different, yet reasonable times.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_bundling_of_different_logical_domains"><a class="anchor" href="#_bundling_of_different_logical_domains"></a><a class="link" href="#_bundling_of_different_logical_domains">1.2. Bundling of different logical domains</a></h3>
<div class="paragraph">
<p>Our example is also very chatty, and hard to understand at first glance.
In fact, this is quite common in similar applications.
The code starts small, easy to understand.
When new features are added, it keeps growing as developers cramp new instructions into methods like <code>completeTransit</code>.</p>
</div>
<div class="paragraph">
<p>Of course, the developers could re-architect the code, to extract instructions to a separate blocks, but that is just a half-measure.
Still, the application will do all the operations, starting from <code>completeTransit</code> method in the same time, and withing the same <em>"script"</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_refactoring_plan"><a class="anchor" href="#_refactoring_plan"></a><a class="link" href="#_refactoring_plan">2. Refactoring plan</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we&#8217;ll plan the refactoring of the Cabs application.
The refactoring will be limited to make the process easy to understand.
The scope of the refactoring will be the extraction of drivers module, which is already a separate domain in the codebase.
Within the scope of the <code>completeTransit</code> method, we&#8217;ll need to shift the way we calculate the fee for the driver.
The calculation will be done asynchronously, and when the driver module publishes the calculation result, it will be saved back into the database.</p>
</div>
<div class="paragraph">
<p>The base for the refactoring is the <em>Event Mesh</em> pattern, and the asynchronous communication will be done with <em>Cloud Events</em>.</p>
</div>
<div class="paragraph">
<p>After the refactoring, the <code>completeTransit</code> code will use two event types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CalculateFee</code>&#8201;&#8212;&#8201;a command event, to calculate fee for the driver for given ride</p>
</li>
<li>
<p><code>DriverFeeCalculated</code>&#8201;&#8212;&#8201;an information event, fired when the calculator does the logic to calculate the requested fee.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The diagram below shows the sequence of operations that happen when we initiate refactored <code>completeTransit</code> code.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://www.plantuml.com/plantuml/svg/VP1DJiCm58JtFiMZ-rmWYwgqeHkeX2WNUBK7Ok4ubdyYzVQuZKbe5TZ5olTcFiqcHFOnTKOyn1OTIC8d0xPLdwBH5iBb_rfgnpRIwWMVBC_qwDoAED3ul4MUBKSzW9u6vES1eRsYMzz_mT-YZS-W3tJeLUwyOdlW23zeYJkK8vyuZ52p5O9bRk687uTYLgrB4zNqcav6XvPsR6GocTsZQ8d2L1aV3slQzVP3-uuKpCNgB1JkEwQpzI_FcjxoL5XgcUvdMioVL4soi-iuIOQcE5N259RYPgKYMNJ-3lfdkMPRqp7s7lJkjQFBvWihR61Lwimt" alt="VP1DJiCm58JtFiMZ rmWYwgqeHkeX2WNUBK7Ok4ubdyYzVQuZKbe5TZ5olTcFiqcHFOnTKOyn1OTIC8d0xPLdwBH5iBb rfgnpRIwWMVBC qwDoAED3ul4MUBKSzW9u6vES1eRsYMzz mT YZS W3tJeLUwyOdlW23zeYJkK8vyuZ52p5O9bRk687uTYLgrB4zNqcav6XvPsR6GocTsZQ8d2L1aV3slQzVP3 uuKpCNgB1JkEwQpzI FcjxoL5XgcUvdMioVL4soi iuIOQcE5N259RYPgKYMNJ 3lfdkMPRqp7s7lJkjQFBvWihR61Lwimt" width="100%">
</div>
</div>
<div class="paragraph">
<p>The diagram illustrates the flow of events between the legacy application, the <em>Knative Event Mesh</em>, the fee calculator service, and the datastore.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_run_this_demonstration"><a class="anchor" href="#_run_this_demonstration"></a><a class="link" href="#_run_this_demonstration">3. Run this demonstration</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next, you can learn how to walk through this demo.</p>
</div>
<div class="sect2">
<h3 id="_before_getting_started"><a class="anchor" href="#_before_getting_started"></a><a class="link" href="#_before_getting_started">3.1. Before getting started</a></h3>
<div class="paragraph">
<p>We&#8217;ll be using the Red Hat OpenShift Container Platform (OCP) 4.x cluster, so make sure you have it available in your environment.</p>
</div>
<div class="paragraph">
<p>You could use the <a href="https://developers.redhat.com/products/openshift/overview">Red Hat&#8217;s Developer Sandbox</a> to spin up an instance for you.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can use the <a href="https://developers.redhat.com/products/openshift-local/overview">OpenShift Local</a> installation.
Make sure to give it enough resources to fit the Serverless Operator and our demo application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_installing_the_demo"><a class="anchor" href="#_installing_the_demo"></a><a class="link" href="#_installing_the_demo">3.2. Installing the demo</a></h3>
<div class="sect3">
<h4 id="_installing_the_serverless_operator"><a class="anchor" href="#_installing_the_serverless_operator"></a><a class="link" href="#_installing_the_serverless_operator">3.2.1. Installing the Serverless Operator</a></h4>
<div class="paragraph">
<p>To install the Serverless Operator, follow <a href="https://docs.openshift.com/serverless/1.35/install/preparing-serverless-install.html">the documentation steps</a>.</p>
</div>
<div class="paragraph">
<p>The <strong>TL;DR</strong> version would be to apply the following manifest, and wait until the operator is ready:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Namespace
metadata:
  name: openshift-serverless
---
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: openshift-serverless
  namespace: openshift-serverless
spec: {}
---
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: serverless-operator
  namespace: openshift-serverless
spec:
  channel: stable
  name: serverless-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are commands to apply the above manifests.</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">git clone https://github.com/cardil/cabs-usvc
oc apply -f cabs-usvc/deploy/serverless/operator.yaml
oc wait csv/serverless-operator.v1.35.0 \
  --for 'jsonpath={.status.conditions[?(@.phase == "Succeeded")]}'</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Replace the <code>v1.35.0</code> with the actual version of the Serverless Operator.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s the expected output</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">namespace/openshift-serverless created
operatorgroup.operators.coreos.com/openshift-serverless created
subscription.operators.coreos.com/serverless-operator created
clusterserviceversion.operators.coreos.com/serverless-operator.v1.35.0 condition met</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_installing_the_serving_and_eventing_components"><a class="anchor" href="#_installing_the_serving_and_eventing_components"></a><a class="link" href="#_installing_the_serving_and_eventing_components">3.2.2. Installing the Serving and Eventing components</a></h4>
<div class="paragraph">
<p>To install the Serving and Eventing components, follow <a href="https://docs.openshift.com/serverless/1.35/install/installing-knative-serving.html">the Serving documentation steps</a> and <a href="https://docs.openshift.com/serverless/1.35/install/installing-knative-eventing.html">the Eventing documentation steps</a>.</p>
</div>
<div class="paragraph">
<p>Again for <strong>TL;DR</strong> version for small, development purposes, you could apply the following manifests, and wait until the components are ready for operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Namespace
metadata:
  name: knative-serving
---
apiVersion: operator.knative.dev/v1beta1
kind: KnativeServing
metadata:
  name: knative-serving
  namespace: knative-serving
spec:
  high-availability:
    replicas: 1
---
apiVersion: v1
kind: Namespace
metadata:
  name: knative-eventing
---
apiVersion: operator.knative.dev/v1beta1
kind: KnativeEventing
metadata:
  name: knative-eventing
  namespace: knative-eventing
spec:
  high-availability:
    replicas: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are commands to apply the above manifests.</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc apply \
  -f cabs-usvc/deploy/serverless/serving.yaml \
  -f cabs-usvc/deploy/serverless/eventing.yaml

oc wait knativeserving/knative-serving \
  --namespace knative-serving \
  --for 'condition=Ready=True'
oc wait knativeeventing/knative-eventing \
  --namespace knative-eventing \
  --for 'condition=Ready=True'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s the expected output</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">Warning: resource namespaces/knative-serving is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by oc apply. oc apply should only be used on resources created declaratively by either oc create --save-config or oc apply. The missing annotation will be patched automatically.
namespace/knative-serving configured
knativeserving.operator.knative.dev/knative-serving created
Warning: resource namespaces/knative-eventing is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by oc apply. oc apply should only be used on resources created declaratively by either oc create --save-config or oc apply. The missing annotation will be patched automatically.
namespace/knative-eventing configured
knativeeventing.operator.knative.dev/knative-eventing created
knativeserving.operator.knative.dev/knative-serving condition met
knativeeventing.operator.knative.dev/knative-eventing condition met</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_installing_the_demo_applications"><a class="anchor" href="#_installing_the_demo_applications"></a><a class="link" href="#_installing_the_demo_applications">3.2.3. Installing the demo applications</a></h4>
<div class="paragraph">
<p>To install the Demo application, apply the following manifests.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/cardil/cabs-usvc/blob/main/deploy/apps/legacy.yaml">The legacy application</a></p>
</li>
<li>
<p><a href="https://github.com/cardil/cabs-usvc/blob/main/deploy/db/redis.yaml">The Drivers database</a></p>
</li>
<li>
<p><a href="https://github.com/cardil/cabs-usvc/blob/main/deploy/apps/drivers.yaml">The Drivers module</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are commands to apply the above manifests.</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc create ns demo
oc apply \
  -f cabs-usvc/deploy/db/redis.yaml \
  -f cabs-usvc/deploy/apps/drivers.yaml \
  -f cabs-usvc/deploy/apps/legacy.yaml

oc wait ksvc/drivers \
  --namespace demo \
  --for condition=Ready=True
oc wait ksvc/legacy \
  --namespace demo \
  --for condition=Ready=True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s the expected output</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">namespace/demo created
pod/redis created
service/redis created
service.serving.knative.dev/drivers created
service.serving.knative.dev/legacy created
service.serving.knative.dev/drivers condition met
service.serving.knative.dev/legacy condition met</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_the_event_mesh"><a class="anchor" href="#_configuring_the_event_mesh"></a><a class="link" href="#_configuring_the_event_mesh">3.2.4. Configuring the Event Mesh</a></h4>
<div class="paragraph">
<p>To configure the Event Mesh, apply the following manifests.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/cardil/cabs-usvc/blob/main/deploy/mesh/broker.yaml"><em>Broker</em></a></p>
</li>
<li>
<p><a href="https://github.com/cardil/cabs-usvc/blob/main/deploy/mesh/sources.yaml">Sources</a></p>
</li>
<li>
<p><a href="https://github.com/cardil/cabs-usvc/blob/main/deploy/mesh/triggers.yaml">Triggers</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are commands to apply the above manifests.</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc apply \
  -f cabs-usvc/deploy/mesh/broker.yaml \
  -f cabs-usvc/deploy/mesh/sources.yaml \
  -f cabs-usvc/deploy/mesh/triggers.yaml

oc wait broker/default \
  --namespace demo \
  --for condition=Ready=True
oc wait sinkbinding/drivers-binding \
  --namespace demo \
  --for condition=Ready=True
oc wait sinkbinding/legacy-binding \
  --namespace demo \
  --for condition=Ready=True
oc wait trigger/trg-drivers \
  --namespace demo \
  --for condition=Ready=True
oc wait trigger/trg-drivers \
  --namespace demo \
  --for condition=Ready=True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s the expected output</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">broker.eventing.knative.dev/default created
sinkbinding.sources.knative.dev/drivers-binding created
sinkbinding.sources.knative.dev/legacy-binding created
trigger.eventing.knative.dev/trg-drivers created
trigger.eventing.knative.dev/trg-legacy created
broker.eventing.knative.dev/default condition met
sinkbinding.sources.knative.dev/drivers-binding condition met
sinkbinding.sources.knative.dev/legacy-binding condition met
trigger.eventing.knative.dev/trg-drivers condition met
trigger.eventing.knative.dev/trg-drivers condition met</code></pre>
</div>
</div>
<div class="paragraph">
<p>The OpenShift Container Platform provides can provide a clear visualization of our deployed solution.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/solution-odc.png" alt="solution odc" width="100%">
</div>
</div>
<div class="paragraph">
<p>The console shows two sink bindings on the left, and they are feeding the events from the applications to the <em>Broker</em> (depicted in the center).
The <em>Broker</em> is the centralized infrastructure piece that ensures a proper decoupling of the services.
On the right, you could see the two applications deployed as <em>Knative</em> services, and two triggers (as lines) that configure the <em>Event Mesh</em> to feed appropriate events to the applications.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_walkthrough_guide"><a class="anchor" href="#_walkthrough_guide"></a><a class="link" href="#_walkthrough_guide">3.3. Walkthrough guide</a></h3>
<div class="paragraph">
<p>With the demo pieces deployed on the cluster, we could go ahead with testing the functionality.</p>
</div>
<div class="paragraph">
<p>For the sake of brevity, the legacy application, at startup, prepares some development data in the in-memory database its running on.
We will leverage that data to complete transit without the hassle of simulating the whole ride.</p>
</div>
<div class="paragraph">
<p>Because we use serverless deployments, the services could be scaled to zero.
This fact makes it a bit harder to listen to the application logs.
We recommend using <a href="https://github.com/stern/stern"><code>stern</code> tool</a> to easily listen to both apps, even across scale to zero periods.</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">stern \
  --namespace demo \
  --container user-container \
  '(legacy|drivers).*'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use a regular <code>oc</code> command and a bit of scripting:</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc logs \
  --selector app=legacy \
  --namespace demo \
  --follow &amp;

while [ $(oc get pod --namespace demo --selector app=drivers -o name | wc -l) -eq 0 ]; do \
  sleep 1; done &amp;&amp; oc wait pod \
  --namespace demo \
  --selector app=drivers \
  --for condition=Ready=True &amp;&amp; \
  oc logs \
  --selector app=drivers \
  --namespace demo \
  --follow</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the second terminal, call the legacy endpoint by sending a <em>POST</em> message like the following:</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">curl -Lk -v -X POST -H 'Content-Type: application/json' \
  $(oc get ksvc legacy --namespace demo -o jsonpath='{.status.url}')/transits/8/complete \
  --data-binary @- &lt;&lt; EOF
{
  "country": "Polska",
  "city": "Warszawa",
  "street": "Å»ytnia",
  "buildingNumber": 32,
  "hash": -580606919
}
EOF</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should observe the cURL command succeeded, and return the ride data.
Moreover, the logs of both applications should be updated.</p>
</div>
<div class="paragraph">
<p>On the <em>Legacy</em> application you could see the log line, with shows the application is sending the <em>Cloud Event</em> to the <em>Event Mesh</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>INFO 1 --- [nio-8080-exec-1] i.l.cabs.common.cloudevents.Publisher    :
Publishing event to http://broker-ingress.knative-eventing.svc.cluster.local/demo/default :
CloudEvent{id='83720fe5-02ee-4a3e-9b22-5c287fb68d10',source=usvc://cabs/legacy,
type='cabs.drivers.calculate-fee', datacontenttype='application/json',
subject='4e630a96-4d5c-488c-a53b-9554c0bcb97e',time=2025-02-04T17:32:20.638351262Z,
data=BytesCloudEventData{value=[123, 34, 100, 114, 105, 118, 101, 114, 45, 105,
100, 34, 58, 49, 57, 57, 51, 52, 51, 50, 53, 53, 50, 44, 34, 116, 114, 97, 110,
115, 105, 116, 45, 112, 114, 105, 99, 101, 34, 58, 53, 49, 48, 48, 125]},
extensions={}}</pre>
</div>
</div>
<div class="paragraph">
<p>You can notice the <code>cabs.drivers.calculate-fee</code> event was later routed to the <em>Drivers</em> service, which calculated the fee.
After the fee was calculated, the <code>cabs.drivers.driver-fee</code> event was published back into the <em>Event Mesh</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[INFO  drivers::app::events] Received event:
    CloudEvent:
      specversion: '1.0'
      id: 'f94792bc-9c38-4db1-8da6-b6a28d1b4847'
      type: 'cabs.drivers.calculate-fee'
      source: 'usvc://cabs/legacy'
      datacontenttype: 'application/json'
      subject: '005be37e-8971-4a5b-b5e7-dd18de3c1184'
      time: '2025-02-04T17:48:11.641317948+00:00'
      knativearrivaltime: '2025-02-04T17:48:11.655926003Z'
      Binary data: "{\"driver-id\":1993432552,\"transit-price\":5100}"

[DEBUG drivers::drivers::service] fee event: Subject {
 id: Some("005be37e-8971-4a5b-b5e7-dd18de3c1184"),
 entity: CalculateFeeEvent {
  driver_id: Identifier(1993432552),
  transit_price: Money(5100) } }
[DEBUG drivers::drivers::service] fee: Money(4856)
[DEBUG drivers::support::cloudevents] sending cabs.drivers.driver-fee event to
 http://broker-ingress.knative-eventing.svc.cluster.local/demo/default:
  Event { attributes: V10(Attributes { id: "939babd7-6a85-4859-b45b-66087aba9418",
   ty: "cabs.drivers.driver-fee", source: "usvc://cabs/drivers",
   datacontenttype: Some("application/json"), dataschema: None,
   subject: Some("005be37e-8971-4a5b-b5e7-dd18de3c1184"),
   time: Some(2025-02-04T17:48:12.897943139Z) }),
   data: Some(Json(Object {"driver-id": Number(1993432552), "fee": Number(4856)})),
   extensions: {} }</pre>
</div>
</div>
<div class="paragraph">
<p>In the end, the <code>cabs.drivers.driver-fee</code> event was routed to the <em>Legacy</em> application, by <em>Event Mesh</em>.
You could see the evidence of it in the logs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>INFO 1 --- [nio-8080-exec-2] i.l.c.ride.details.TransitDetailsFacade  :
 Driver fee calculated for transit 005be37e-8971-4a5b-b5e7-dd18de3c1184: 48.56</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_in_depth_refactoring"><a class="anchor" href="#_in_depth_refactoring"></a><a class="link" href="#_in_depth_refactoring">4. In-depth look at the refactoring</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we&#8217;ll refactor the Cabs application.
The refactoring will be limited to make the process easy to understand.
The scope of the refactoring will be the extraction of drivers module, which is already a separate domain in the codebase.
Within the scope of the <code>completeTransit</code> method, we&#8217;ll need to shift the way we calculate the fee for the driver.
The calculation will be done asynchronously, and when the driver module publishes the calculation result, it will be saved back into the database.</p>
</div>
<div class="paragraph">
<p>The base for the refactoring is the <em>Event Mesh</em> pattern, and the asynchronous communication will be done with <em>Cloud Events</em>.</p>
</div>
<div class="sect2">
<h3 id="_drivers_module"><a class="anchor" href="#_drivers_module"></a><a class="link" href="#_drivers_module">4.1. Drivers module</a></h3>
<div class="paragraph">
<p>The functionality around drivers is already quite separated in the codebase, so it is a good staring point to extract into a separate module.
The drivers module will become a standalone web service, deployed on the <em>Kubernetes</em> cluster.
The implementation of the drivers module will be done with <em>Rust</em> for this example.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the <em>Rust</em> code for calculate fee functionality.
The entrypoint is the <em>Cloud Event</em> of type <code>cabs.drivers.calculate-fee</code> we are expecting the <em>Event Mesh</em> will route.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">impl Service {
  pub async fn calculate_fee(&amp;mut self, ce: Event) -&gt; Result&lt;()&gt; {
    let calc_fee_intent = Self::unwrap_calculatefee(ce)?; <i class="conum" data-value="1"></i><b>(1)</b>
    let subject = calc_fee_intent.id.clone();

    log::debug!("calculate fee for: {:?}", calc_fee_intent);
    let drv = self.repo.get(&amp;calc_fee_intent.entity.driver_id).await?;

    let fee = drv.calculate_fee(&amp;calc_fee_intent.entity.transit_price); <i class="conum" data-value="2"></i><b>(2)</b>

    log::debug!("fee value: {:?}", fee);

    let driverfee_event = DriverFeeEvent {
        driver_id: calc_fee_intent.entity.driver_id,
        fee,
    }; <i class="conum" data-value="3"></i><b>(3)</b>

    let mut builder = driverfee_event.to_builder(); <i class="conum" data-value="3"></i><b>(3)</b>
    if let Some(id) = subject {
        builder = builder.subject(id);
    } <i class="conum" data-value="3"></i><b>(3)</b>
    let ce = builder.build().map_err(error::ErrorInternalServerError)?; <i class="conum" data-value="3"></i><b>(3)</b>

    Sender::new(&amp;self.config).send(ce).await?; <i class="conum" data-value="4"></i><b>(4)</b>

    Ok(())
  }
  // [..]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above code, we are doing the following:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We are unwrapping <em>Cloud Event</em> envelope into an internal, domain, fee value object.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We are calculating the fee value using some domain logic.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We are wrapping the calculated fee value into a new <em>Cloud Event</em>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We are sending the fee, as <em>Cloud Event</em>, back to the <em>Event Mesh</em> using <em>HTTP REST</em> client.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, in order for this method to be called, we need to route the event from the HTTP listener:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">pub fn routes() -&gt; impl HttpServiceFactory + 'static {
    web::resource("/").route(web::post().to(recv))
}

async fn recv(
    ce: Event,
    state: web::Data&lt;State&gt;,
    binding: web::Data&lt;Binding&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    log::info!("Received event:\n{}", ce);

    let mut svc = service::new(state, binding).await?;

    match ce.ty() {
        "cabs.drivers.calculate-fee" =&gt; svc.calculate_fee(ce).await,
        _ =&gt; Err(error::ErrorBadRequest("unsupported event type")),
    }?;

    Ok(HttpResponse::Ok().finish())
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The example above uses a simple switch statement to determine the route for the given type of the event.
In a real application, you would probably use a more complex logic to determine which method should be called.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s see also the <em>Cloud Event</em> sender, that uses the <em>HTTP REST</em> client to send events to the <em>Event Mesh</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">impl Sender {
    pub async fn send(&amp;self, ce: Event) -&gt; Result&lt;()&gt; {
        log::debug!("sending {} event to {}:\n{:?}", ce.ty(), &amp;self.sink, ce,);

        let response = self
            .client
            .post(&amp;self.sink) <i class="conum" data-value="1"></i><b>(1)</b>
            .event(ce)
            .map_err(error::ErrorInternalServerError)?
            .send()
            .await
            .map_err(error::ErrorInternalServerError)?;

        match response.status().is_success() {
            true =&gt; Ok(()),
            false =&gt; {
                log::error!("failed to send event: {:#?}", response);
                Err(error::ErrorInternalServerError(format!(
                    "failed to send event: {}",
                    response.status()
                )))
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The client uses <em>POST</em> method, to send the <em>JSON</em> representation of the event to the sink.
The <em>sink</em> is the URL of the target, in this case the url of the <em>Event Mesh</em>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_event_mesh"><a class="anchor" href="#_event_mesh"></a><a class="link" href="#_event_mesh">4.2. Event Mesh</a></h3>
<div class="paragraph">
<p>In this section, we&#8217;ll use the <em>Event Mesh</em> setup to communication between the extracted Drivers module and the different parts of the application.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the configuration of the <em>Event Mesh</em>'s central component, the <em>Broker</em>, which will be used in this example.
The <em>Broker</em> here is the <em>Knative</em> component, and will be deployed in the <em>Kubernetes</em> cluster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: eventing.knative.dev/v1
kind: Broker
metadata:
  name: default
  namespace: demo
spec:
  delivery:
    backoffDelay: PT0.2S <i class="conum" data-value="1"></i><b>(1)</b>
    backoffPolicy: exponential <i class="conum" data-value="2"></i><b>(2)</b>
    retry: 10 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>backoffDelay</code> is the delay between retries, and us use <code>200ms</code> initially.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>backoffPolicy</code> is set to <code>exponential</code>, which means that the delay will be doubled each time.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>retry</code> is the number of times we retry before giving up.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In our example, the policy is <code>exponential</code>, and the <code>retry</code> is 10, which means that after approximately 6 min and 50 sec the event will be dropped (or routed to the <code>deadLetterSink</code> if configured).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A <code>deadLetterSink</code> option could be configured for the <em>Broker</em> to send the events that failed to be delivered in time to a back-up location.
Events captured in a back-up location can be re-transmitted into the <em>Event Mesh</em> later by reconfiguring the <em>Mesh</em> (after resolving the outage or deploying a bug fix).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_legacy_application_changes"><a class="anchor" href="#_legacy_application_changes"></a><a class="link" href="#_legacy_application_changes">4.3. Legacy application changes</a></h3>
<div class="paragraph">
<p>The last part of the refactoring will be the changes needed in our legacy Java application.
We need to remove the <em>Drivers</em> logic and send events to the <em>Event Mesh</em> instead.
We also need to accept new events coming from the <em>Event Mesh</em>, as the calculated fee will be transmitted as such.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the refactored code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void completeTransit(UUID requestUUID, AddressDTO destinationAddress) {
    // ...
    Money finalPrice = completeTransitService.completeTransit(driverId, requestUUID, from, to);
    // ...
    driverFeeService.calculateDriverFee(requestUUID, finalPrice, driverId); <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}

@EventListener <i class="conum" data-value="2"></i><b>(2)</b>
public void driverFeeCalculated(DriverFee driverFee) { <i class="conum" data-value="3"></i><b>(3)</b>
    Objects.requireNonNull(driverFee.ctx.getSubject());
    UUID id = UUID.fromString(driverFee.ctx.getSubject());
    transitDetailsFacade.driverFeeCalculated(id, driverFee.data.fee);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice, we are just invoking the <code>calculateDriverFee</code>, that doesn&#8217;t return anything.
It&#8217;s asynchronous.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We are using the <code>@EventListener</code> annotation to listen for the domain events within the application.
Don&#8217;t confuse this with <em>Cloud Events</em> that are sent and received outside the application.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The exact fee is calculated by the <em>Drivers</em> module, and we&#8217;ll be notified later, with the <code>driverFeeCalculated</code> method.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To communicate with the <em>Event Mesh</em>, we need to add a new <em>Cloud Event</em> sender and listener.
That&#8217;s being done similarly, as in the case of <em>Rust</em> application.</p>
</div>
<div class="paragraph">
<p>Below, you can see how you may implement the <em>Cloud Event</em> sender:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class DriverFeeService {

    private final CloudEventSender eventSender;

    @Autowired
    public DriverFeeService(EventSender eventSender) {
        this.eventSender = eventSender;
    }

    public void calculateDriverFee(UUID rideId, Money transitPrice, Long driverId) {
        eventSender.send(new CalculateFee(
            rideId,
            driverId,
            transitPrice.toInt()
        ));
    }
}

@Service
public class CloudEventSender {

  private static final Logger log = LoggerFactory.getLogger(EventSender.class);

  private final KnativeConfig knative;
  private final List&lt;Into&lt;?&gt;&gt; converters;

  @Autowired
  CloudEventSender(KnativeConfig knative, List&lt;Into&lt;?&gt;&gt; converters) {
    this.knative = knative;
    this.converters = converters;
  }

  public void send(Object event) {
    try {
      unsafeSend(event);
    } catch (IOException e) {
      throw new UncheckedIOException(e);
    }
  }

  private &lt;T&gt; void unsafeSend(T event) throws IOException {
    Into&lt;T&gt; convert = (Into&lt;T&gt;) converters.stream()
        .filter(c -&gt; c.accepts(event))
        .findFirst()
        .orElseThrow(() -&gt; new IllegalArgumentException(
          "Cannot find converter for " + event.getClass()));
    CloudEvent ce = convert.into(event);
    URL url = knative.getSink();
    log.info("Publishing event to {} : {}", url, ce);
    HttpURLConnection http = (HttpURLConnection) url.openConnection();
    http.setRequestMethod("POST");
    http.setDoOutput(true);
    http.setDoInput(true);

    HttpMessageWriter messageWriter = createMessageWriter(http);
    messageWriter.writeBinary(ce);

    int code = http.getResponseCode();
    if (code &lt; 200 || code &gt;= 300) {
      throw new IOException("Unexpected response code " + code);
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once again, notice this is just a simple <em>HTTP</em> client doing the <em>POST</em> request, with the body being the JSON representation of the <em>CloudEvent</em>.</p>
</div>
<div class="paragraph">
<p>The last part to see is the <em>HTTP</em> listener on the legacy application side.
This listener will be responsible for receiving events from <em>Knative&#8217;s Event Mesh</em> and converting them into our custom event type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class CloudEventReceiver {
  private static final Logger log = LoggerFactory.getLogger(Receiver.class);

  private final EventsPublisher eventsPublisher;
  private final List&lt;From&lt;?&gt;&gt; froms;

  @Autowired
  Receiver(EventsPublisher eventsPublisher, List&lt;From&lt;?&gt;&gt; froms) {
    this.eventsPublisher = eventsPublisher;
    this.froms = froms;
  }

  @PostMapping("/")
  public void receive(@RequestBody CloudEvent event) {
    log.info("Received event: {}", event);

    for (From&lt;?&gt; from : froms) {
      if (from.matches(event)) {
        Event ev = from.fromCloudEvent(event); <i class="conum" data-value="1"></i><b>(1)</b>
        eventsPublisher.publish(ev); <i class="conum" data-value="2"></i><b>(2)</b>
        return;
      }
    }

    throw new IllegalStateException("No matching event type consumer found");
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We unwrap the <em>CloudEvent</em> into our domain event type (in the example that&#8217;s the <code>DriverFeeCalculated</code> type)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>And publish it withing the application, using the framework&#8217;s <em>EventsPublisher</em> implementation.
The domain events will be transmitted to the methods annotated with <code>@EventListener</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Don&#8217;t confuse the framework&#8217;s <em>EventsPublisher</em> with <em>Cloud Event</em> sender and receiver.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_the_wiring_of_our_event_mesh"><a class="anchor" href="#_the_wiring_of_our_event_mesh"></a><a class="link" href="#_the_wiring_of_our_event_mesh">4.4. The wiring of our <em>Event Mesh</em></a></h3>
<div class="paragraph">
<p>To complete the solution, we need to configure the <em>Event Mesh</em>.
The configuration describes the rules for receiving and sending events from and to the <em>Event Mesh</em> and the application modules.</p>
</div>
<div class="paragraph">
<p>Here are the sources in our case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: sources.knative.dev/v1
kind: SinkBinding
metadata:
  name: drivers-binding
  namespace: demo
spec:
  sink:
    ref:
      apiVersion: eventing.knative.dev/v1
      kind: Broker
      name: default
      namespace: demo
  subject:
    apiVersion: serving.knative.dev/v1
    kind: Service
    name: drivers
    namespace: demo
---
apiVersion: sources.knative.dev/v1
kind: SinkBinding
metadata:
  name: legacy-binding
  namespace: demo
spec:
  sink:
    ref:
      apiVersion: eventing.knative.dev/v1
      kind: Broker
      name: default
      namespace: demo
  subject:
    apiVersion: serving.knative.dev/v1
    kind: Service
    name: legacy
    namespace: demo</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are using the <em>SinkBinding</em> resource to bind an event source (the <em>Service</em>) with an event sink (<em>Broker</em>).
We have two applications that will feed their events into the <em>Event Mesh</em>, so we need two <em>SinkBinding</em> resources.</p>
</div>
<div class="paragraph">
<p>Lastly, we have to configure the <em>Broker</em> to send events from the <em>Event Mesh</em> to the expected application modules.
We use the <em>Trigger</em> resource for this purpose.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: trg-drivers
  namespace: demo
spec:
  broker: default
  filter:
    attributes:
      type: cabs.drivers.calculate-fee <i class="conum" data-value="1"></i><b>(1)</b>
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: drivers
      namespace: demo
---
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: trg-legacy
  namespace: demo
spec:
  broker: default
  filter:
    attributes:
      type: cabs.drivers.driver-fee <i class="conum" data-value="1"></i><b>(1)</b>
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: legacy
      namespace: demo</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note, we specify the type of the event, as a filter.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a><a class="link" href="#_conclusion">5. Conclusion</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s step back and take a look at what we have accomplished.</p>
</div>
<div class="paragraph">
<p>The refactored application code fragment is now distributed, resilient, and eventually consistent.
It will gracefully handle the failures that may happen while calculating the driver&#8217;s fee.
The <em>Event Mesh</em> will make sure to retry the event delivery, in case of failures on either side.</p>
</div>
<div class="paragraph">
<p>We could extend the refactoring, even further, with the same principle, making the whole application modern, responsible, and without incorrect, unnecessary, transactional behavior.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="02-architecture.html" class="query-params-link">2. Architecture</a></span>
  <span class="next"><a href="developer-resources.html" class="query-params-link">4. Developer Resources</a></span>
</nav>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <img
          src="../_/img/app-services-logo.png" height="40px" alt="Cloud Native Architecture Solution Patterns"  href="https://redhat.com" ></a>
</footer><script src="../_/js/vendor/clipboard.js"></script>
<script src="../_/js/site.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>
  </body>
</html>
